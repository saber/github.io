<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ubuntu16.04 Ceres 安装及 find_package() 命令使用原理]]></title>
    <url>%2Farchives%2F7dcb4bb9.html</url>
    <content type="text"><![CDATA[摘要: 本文讲述了 Ceres 的基本安装，以及涉及到 cmake 容易出错的知识点 find_package() 使用，以及多版本 Ceres、OpenCV 使用的基本原理。 正文: 1、安装相应的依赖12345678910111213# CMakesudo apt-get install cmake# google-glog + gflagssudo apt-get install libgoogle-glog-dev# BLAS &amp; LAPACKsudo apt-get install libatlas-base-dev# Eigen3sudo apt-get install libeigen3-dev# SuiteSparse and CXSparse (optional)# - If you want to build Ceres as a *static* library (the default)# you can use the SuiteSparse package in the main Ubuntu package# repository:sudo apt-get install libsuitesparse-dev 2、编译安装（Ceres 有一些编译选项可参考官网）(1)、默认路径/选项安装（标准路径）12345mkdir buildcd buildcmake ..make -j4sudo make install 此时直接 find_package(Ceres)即可找到该库。 (2)、指定路径/选项安装（非标准路径）这里的选项，可以参考给定的 ceres 官网，下面仅以指定安装目录为例，也称为局部安装，适用于多个安装版本。 12345mkdir build cd buildcmake -D CMAKE_INSTALL_PREFIX="/some/where/local" ..make -j4make install 此时在 CMakeLists.txt 中使用 find_package(Ceres REQUIRED PATHS &quot;/some/where/local/ &quot;)才会找到 Ceres 库的头文件、库文件。 注意: 这种安装方式可以适用于多版本 Ceres 的使用，如果安装了两个 Ceres 在不同的目录中，那么在使用的过程中，我们只要在 find_package( ) 中 PATHS 后面指定其中一个版本的安装路径即可。 (3)、非标准安装的另一种替代品(ceres 特有的选项)1234mkdir buildcd buildcmake -D EXPORT_BUILD_DIR=ON ..make -j4 因为默认情况下，Ceres 安装到系统默认路径/标准路径，然后才可以通过 find_package 查找到。对于 export( PACKAGE Ceres )，这种方式会让 HOME 目录下的 .cmake 中出现 packages/Ceres 文件夹，在 Ceres 文件夹里有一个文件。该文件记录了包含 CeresConfig.cmake 的地址，一般是编译 Ceres 的原始目录地址，比如这里的 build 目录所在的绝对路径，然后 cmake 会根据该文件提供的路径找到 CeresConfig.cmake 文件，进而利用 CeresConfig.cmake 中的语句，找到 Ceres 库的头文件和库文件。这个是 cmake 特有的搜索方式，参考 user’s local CMake package registry。接下来就可以直接在 CMakeLists.txt 中 find_package(Ceres REQUIRED) 了。这部分会在『 推广』部分再次提到。Ceres 库本身会通过 EXPORT_BUILD_DIR=ON 开启这种方式。 (4)、通用的方式(仅编译不安装，适合多版本)1234mkdir build cd buildcmake ..make -j4 通过上面前三种方式可以了解到，find_package() 本质上是在查找 CeresConfig.cmake 这个文件，前三种方式使用了不同的 cmake 搜索路径，我们也可以直接在 CMakeLists.txt 中加上 set(Ceres_DIR &quot;包含 CeresConfig.cmake文件的绝对路径，一般编译后的文件夹中&quot;)，然后在 find_package(Ceres)，CMake 就会自动的在这个路径下查找执行 CeresConfig.cmake 文件，之后这个 Ceres 库我们就可以使用了。即使多个版本，我们只要把上面 set 语句的路径部分替换一下就能使用不同版本 Ceres了。 (5)、总结为了更好的移植 CMakeLists.txt 代码，也就是假设别人使用的是第一种安装方式。即安装到了系统的默认路径，那么我们在 CMakeLists.txt 中只能写 find_package(Ceres Required)，这样一来，我们最好做的就是按照 (3) 方式，也就是在 home 目录下 .cmake/packages 文件中自动出现 Ceres 文件夹，然后里面的文件中写上了含有 CeresConfig.cmake 文件的绝对地址。如果我们有多个 Ceres 编译好的源码版本，我们可以在 .cmake/packages/Ceres /xxx_filename 文件中修改为不同 Ceres 源码版本目录地址，这样就可以使用不同的 Ceres 版本了。当发布代码的时候，其他人使用不必做任何修改即可运行。 3、推广对于 slam 常用的 Pangolin 、Sophus 库都是只编译即可。因为在他们的 CMakeLists.txt 中都有 export(PACKAGE Sopus/Pangolin )，然后 cmake 会自动将包含 SopusConfig.cmake 和 PangolinConfig.cmake 文件的路径分别放到 ./cmake/packages/Sophus/xxx_filename 和 .cmake/packages/Pangolin/xxx_filename，然后系统会自动找到。这种方式其实我们可以推广到其他的库，比如 OpenCV 库，我们可以仅编译 OpenCV 的源码不安装。然后在 .cmake/packages/ 中建立 OpenCV 文件夹和一个任意名字的文件，里面写上 OpenCV 源码中包含 OpenCVConfig.cmake 文件的目录地址， 一般是 build 目录，下面列出 .cmake/packages 文件夹下的一些库。 需要注意:这种方式只适用于源码库在编译后提供了 xxxConfig.cmake 文件。这种方式属于 Config 模式。对于经常用到的 g2o 库，因为库的作者没有提供 G2OConfig.cmake 文件。所以没法用这种方式。只能用 Module 模式，这在『 第 4 部分』会讲到。 4、技巧现在简单说一下 find_package()命令常用的查找技巧，首先我们要知道 find_package() 就是为了找到库的头文件和库文件。然而包含库的头文件和库文件的变量都在 Findxxx.cmake 或者 xxxConfig.cmake 中定义着，所以我们只要找到当中的一种 .cmake 文件即可。然后执行这个 .cmake 文件，我们就能得到库来使用。对于 cmake 而言，有两种查找方式。下面分别详细介绍。 (1)、Module 模式(查找Findxxx.cmake 文件)CMake 会优先搜索 CMAKE_MODULE_PATH 指定的路径，然后搜索自己自带的 Modules 路径。所以一般来说，最常用就是在自己工程的 CMakeLists.txt 文件中更改 CMAKE_MODULE_PATH 这个变量值，或者把包含 Findxxx.cmake 文件的路径附加到这个变量中。之后就可以使用 find_package() 查找到对应的库。两种方式对应如下代码： 1234set(CMAKE_MODULE_PATH $&#123;CMAKE_MODULE_PATH&#125; $&#123;CMAKE_SOURCE_DIR&#125;/cmake_modules/") # 后面这个路径就是在自己的工程目录中添加一个 cmake_modules 文件# 一般推荐使用这个方式添加LIST(APPEND CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake_modules) 对于 CMake 本身自带的模块路径，我们没必要添加 Findxxx.cmake 文件到其中。只要利用好 CMake 为我们提供的 CMAKE_MODULE_PATH 这个变量即可。 (2)、Config 模式(查找 xxxConfig.cmake 文件）这个文件是库的作者提供的，或者你看明白库作者写的 CMakeLists.txt 文件后，修改生成 xxxConfig.cmake 文件)，上面讲解的 Ceres 安装方式就是利用这种模式。CMake 会优先搜索 xxx_DIR 指定的路径，然后第二优先级才是搜索 /usr/lib/cmake/xxx/ 中对应的xxxConfig.cmake 文件。因此最常使用的做法，指定 xxx_DIR 到包含 xxxConfig.cmake 文件的路径。下面是最常用的命令。 12set(xxx_DIR "dir") # dir 是包含 xxxConfig.cmake 文件的路径 find_package() (3)、总结可以看出，CMake 提供了灵活的查找库的方式。不论是 Config 模式还是 Module 模式，我们都可以自己定义包含 .cmake 文件的路径，然后用 find_package() 来查找。当然在第 2 点总结部分已经说明，对于 Config 模式，我们就用第 2 点总结推荐的方法。对于一些库，作者没有提供 xxxConfig.cmake 文件，只有 Findxxx.cmake 文件，那么我们只能用 Module 模式，然后推荐用 LIST(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake_modules)，把当前工程用到的 .cmake 文件放在 cmake_modules 文件夹中。这样我们就可以顺利使用 find_package() 查找使用库了。上面介绍的仅仅是 find_package() 经常使用的方法，更进一步介绍可参考 cmake 官网， 5、拓展对于刚刚『 第 3 部分』提到的 export 导出库，可以有如下的例子，我们以 Sophus 库为例。Sophus 库在 CMakeLists.txt 里面开始设定了 Sophus_INCLUDE_DIR、Sophus_LIBRARIES 变量，然后通过 configure_file() 语句根据 SophusConfig.cmake.in 文件生成了 SophusConfig.cmake 文件。命令如下: 123CONFIGURE_FILE( $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/SophusConfig.cmake.in $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/SophusConfig.cmake @ONLY IMMEDIATE ) # @only 表示在 SophusConfig.cmake.in 中只有 @var@ 会被替代，而 $&#123;var&#125; 这种不会被替代。export( PACKAGE Sophus ) # 将当前目录地址导出到 .cmake/packages/Sophus/xxxfilename 里面 configure_file() 的详细用法参考这里。上面这句简单解释就是将前面的 SophusConfig.cmake.in 最后通过 CMakeLists.txt 文件的一些变量替换，最后生成了 SophusConfig.cmake 文件。下面分别列出原始文件以及替换生成的文件。 原始文件 SophusConfig.cmake.in 1234567891011121314151617################################################################################# Sophus source dirset( Sophus_SOURCE_DIR "@CMAKE_CURRENT_SOURCE_DIR@")################################################################################# Sophus build dirset( Sophus_DIR "@CMAKE_CURRENT_BINARY_DIR@")################################################################################set( Sophus_INCLUDE_DIR "@Sophus_INCLUDE_DIR@" )set( Sophus_INCLUDE_DIRS "@Sophus_INCLUDE_DIR@" )set( Sophus_LIBRARIES "@Sophus_LIBRARIES@" )set( Sophus_LIBRARY "@Sophus_LIBRARIES@" )set( Sophus_LIBRARY_DIR "@Sophus_LIBRARY_DIR@" )set( Sophus_LIBRARY_DIRS "@Sophus_LIBRARY_DIR@" ) 替换生成的文件 SophusConfig.cmake 1234567891011121314151617################################################################################# Sophus source dirset( Sophus_SOURCE_DIR "/home/gcj/LocalUser/Repo/slam/Sophus")################################################################################# Sophus build dirset( Sophus_DIR "/home/gcj/LocalUser/Repo/slam/Sophus/build")################################################################################set( Sophus_INCLUDE_DIR "/home/gcj/LocalUser/Repo/slam/Sophus;/usr/local/include/eigen3" )set( Sophus_INCLUDE_DIRS "/home/gcj/LocalUser/Repo/slam/Sophus;/usr/local/include/eigen3" )set( Sophus_LIBRARIES "/home/gcj/LocalUser/Repo/slam/Sophus/build/libSophus.so" )set( Sophus_LIBRARY "/home/gcj/LocalUser/Repo/slam/Sophus/build/libSophus.so" )set( Sophus_LIBRARY_DIR "/home/gcj/LocalUser/Repo/slam/Sophus/build" )set( Sophus_LIBRARY_DIRS "/home/gcj/LocalUser/Repo/slam/Sophus/build" ) 有了 SophusConfig.cmake 文件，在 CMakeLists.txt 中，通过 export(PACKAGE Sophus)，就可以在 $HOME 目录下的 ./cmake/packages/ 自动生成了 Sophus 文件夹和一个文件，文件内容为当前包含 SophusConfig.cmake 文件的地址。一般就是 Sophus 源码包中自己建立的 build 文件夹的绝对地址。 6、参考资料1、https://www.cnblogs.com/newneul/p/8364924.html 2、http://ceres-solver.org/installation.html# 3、http://ceres-solver.org/installation.html#customizing-the-build 4、https://blog.csdn.net/bytxl/article/details/50637277 5、https://cmake.org/cmake/help/v3.2/manual/cmake-packages.7.html#user-package-registry 6、https://cmake.org/cmake/help/v3.0/command/find_package.html]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
        <tag>ceres</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake 两种变量原理]]></title>
    <url>%2Farchives%2Fc9f565b5.html</url>
    <content type="text"><![CDATA[摘要: 本文记录一下 CMake 变量的定义、原理及其使用。CMake 变量包含 Normal Variables、Cache Variables。通过 set 指令可以设置两种不同的变量。也可以在 CMake 脚本中使用和设置环境变量。set(ENV{&lt;variable&gt;} &lt;value&gt;...)，本文重点讲述 CMake 脚本语言特有的两种变量。 正文： 1、两种变量的定义参考 Normal Variables 通过 set(&lt;variable&gt; &lt;value&gt;... [PARENT_SCOPE])这个命令来设置的变量就是 Normal Variables。例如 set(MY_VAL “666”) ，此时 MY_VAL 变量的值就是 666。 Cache Variables 通过 set(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])这个命令来设置的变量就是 Cache Variables。例如 set(MY_CACHE_VAL &quot;666&quot; CACHE STRING INTERNAL)，此时 MY_CACHE_VAL 就是一个 CACHE 变量。 2、两种变量的作用域原理及使用 1、Normal Variables​ 作用域属于整个 CMakeLists.txt 文件，当该文件包含了 add_subdirectory()、include()、macro()、function()语句时，会出现两种不同的效果。 (1)、包含 add_subdirectory()、function()。（本质是值拷贝）假设，我们在工程根目录 CMakeLists.txt 文件中使用 add_subdirectory(src) 包含另一个 src 目录，在 src 目录中有另一个 CMakeLists.txt 文件。在终端运行的目录结构如下： 1234567$ tree.├── CMakeLists.txt└── src └── CMakeLists.txt1 directory, 2 files 以根目录 CMake 文件为父目录，src 目录为子目录，此时子目录 CMake 文件会拷贝一份父目录文件的 Normal 变量。需要说明的是，我们在子目录中如果想要修改父目录 CMake 文件包含的 Normal 变量。必须通过 set(… PARENT_SCOPE) 的方式。下面通过例子来说明。 在父/根目录的 CMakeLists.txt 文件内容如下: 1234567cmake_minimum_required(VERSION 3.10)message("父目录 CMakeLists.txt 文件")set(MY_VAL "666")message("第一次在父目录 MY_VAL=$&#123;MY_VAL&#125;")add_subdirectory(src) message("第二次在父目录，MY_VAL=$&#123;MY_VAL&#125;") 在子目录 src/CMakeLists.txt 文件内容如下： 1234cmake_minimum_required(VERSION 3.10)message("进入子目录 src/CMakeLists.txt 文件")message("在子目录，MY_VAL=$&#123;MY_VAL&#125;")message("退出子目录") 运行结果： 1234567$ cmake .父目录 CMakeLists.txt 文件第一次在父目录 MY_VAL=666进入子目录 src/CMakeLists.txt 文件在子目录，MY_VAL=666退出子目录第二次在父目录，MY_VAL=666 从结果可以看出，在子目录 CMake 文件中可以直接使用父目录定义的 MY_VAL 变量的值 666。当在子目录 CMake 文件中修改 MY_VAL 变量值，看看在父目录中 MY_VAL 的值如何变化。下面仅仅在子目录 CMake 文件中加入一行代码 set(MY_VAL &quot;777&quot;),最后的子目录 CMake 文件代码如下： 123456cmake_minimum_required(VERSION 3.10)message("进入子目录 src/CMakeLists.txt 文件")set(MY_VAL "777") # 刚刚加入的message("在子目录，MY_VAL=$&#123;MY_VAL&#125;")message("退出子目录") 运行结果： 1234567$ cmake .父目录 CMakeLists.txt 文件第一次在父目录 MY_VAL=666进入子目录 src/CMakeLists.txt 文件在子目录，MY_VAL=777退出子目录第二次在父目录，MY_VAL=666 我们发现在 src/CMakeLists.txt 中打印的 MY_VAL 的值是 777，然后退出子目录回到根目录后，打印 MY_VAL 的值仍然是 666。这就说明了：子目录的 CMakeLists.txt 文件仅仅是拷贝了一份父目录的 Normal 变量，即使在子目录 CMake 文件中修改了 MY_VAL 变量，那也只是子目录自己的变量，不是父目录的变量。因为 Normal 变量的作用域就是以 CMakeLists.txt 文件为基本单元。那么我们如何在子目录 CMake 文件中修改父目录 CMake 文件的 Normal 变量呢? 我们需要在子目录 CMakeLists.txt 文件中设置 MY_VAL 时，加上 PARENT_SCOPE 属性。即用如下代码: set(MY_VAL &quot;777&quot; PARENT_SCOPE)，子目录 CMakeLists.txt 文件如下： 123456cmake_minimum_required(VERSION 3.10)message("进入子目录 src/CMakeLists.txt 文件")set(MY_VAL "777" PARENT_SCOPE) # 修改处message("在子目录，MY_VAL=$&#123;MY_VAL&#125;")message("退出子目录") 运行结果: 1234567$ cmake .父目录 CMakeLists.txt 文件第一次在父目录 MY_VAL=666进入子目录 src/CMakeLists.txt 文件在子目录，MY_VAL=666退出子目录第二次在父目录，MY_VAL=777 可以看出在第二次回到父目录时，MY_VAL 的值已经变成了 777。同理，对于 function() 最开始的结论也适用。代码如下： 1234567891011121314cmake_minimum_required(VERSION 3.10)message("父目录 CMakeLists.txt 文件")set(MY_VAL "666")message("第一次在父目录 MY_VAL=$&#123;MY_VAL&#125;")# 函数定义function(xyz test_VAL) # 函数定义处！ set(MY_VAL "888" PARENT_SCOPE) message("functions is MY_VAL=$&#123;MY_VAL&#125;")endfunction(xyz)xyz($&#123;MY_VAL&#125;) # 调用函数message("第二次在父目录，MY_VAL=$&#123;MY_VAL&#125;") 运行结果: 1234父目录 CMakeLists.txt 文件第一次在父目录 MY_VAL=666functions is MY_VAL=666第二次在父目录，MY_VAL=888 可以看出在该函数中使用 MY_VAL 这个变量值，其实就是一份父目录变量的值拷贝，此时打印值为 666。在 函数中修改值，那么也是用 set(${MY_VAL} 888 PARENT_SCOPE)。此时，退出函数第二次打印变量值时。该值就是在函数中修改好的值 888。 本质讲，对于 function() 而言，刚刚说到的父目录其实不是严格正确的。因为函数定义可以是在其他 .cmake 模块文件中定义的。也可以在其他 CMakeLists.txt 文件中调用，因此准确的说，这里的父目录应该改为『调用函数的地方所属的 CMakeLists.txt 』，我们做的这个实验是在根目录 CMakeLists.txt 文件中定义了函数，又在本文件中使用了。因此之前的说法理解其意思即可。对于 add_subdirectory() 而言，其实也是说调用的地方。下面的 include()、macro() 例子会涉及到，将 function() 放在一个外部的 .cmake 文件中。那里也会说明 function() 与 macro() 的不同。 (2）、包含 include()、macro() （本质有点类似 c 中的 #include 预处理含义）现在在上面的根目录中加入了一个 cmake_modules 目录。目录中有一个 Findtest.cmake 文件。新的目录结构如下: 123456789$ tree.├── CMakeLists.txt├── cmake_modules│ └── Findtest.cmake└── src └── CMakeLists.txt2 directories, 3 files 在根目录中的 CMakeLists.txt 文件包含的代码如下: 1234567891011121314151617cmake_minimum_required(VERSION 3.10)message("父目录 CMakeLists.txt 文件")set(MY_VAL "666")message("第一次在父目录 MY_VAL=$&#123;MY_VAL&#125;")# 使用 include() 文件的宏list(APPEND CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake_modules) include(Findtest) # 从 CMAKE_MODULE_PATH 包含的路径中搜索 Findtest.cmake 文件#test($&#123;MY_VAL&#125;) # 调用宏#xyz($&#123;MY_VAL&#125;) # 调用函数#find_package(test REQUIRED) # 从 CMAKE_MODULE_PATH 包含的路径中搜索 Findtest.cmake 文件 与 include () 两者的效果是一样的！message("第二次在父目录，MY_VAL=$&#123;MY_VAL&#125;")message("include test=$&#123;test_VAL&#125;") #message("macro_val=$&#123;macro_val&#125;") cmake_modules/Findtest.cmake 文件内容如下: 123456789101112131415161718# 该文件定义了一个函数以及一个宏message("进入 Findtest.cmake 文件")set(test_VAL "222") # 验证根目录 CMake 文件能够访问这个变量set(MY_VAL "000") # 测试 include() 效果# 宏定义macro(test MY_VA) # 定义一个宏！ set(macro_val "1") # 宏内部定义变量 message("macro is MY_VAL=$&#123;MY_VA&#125;") set(MY_VAL "999") # 直接修改的就是调用该宏所处的文件中的 Normal 变量endmacro(test)# 函数定义function(xyz test_VAL) set(MY_VAL "888" PARENT_SCOPE) # 修改 调用者的 变量 message("function is MY_VAL=$&#123;MY_VAL&#125;")endfunction(xyz) 运行结果： 123456$ cmake .父目录 CMakeLists.txt 文件第一次在父目录 MY_VAL=666进入 Findtest.cmake 文件第二次在父目录，MY_VAL=000include test=222 从结果可以看出，include() 内部是可以修改调用者 MY_VAL 变量。include() 包含的文件内定义的变量 test_VAL，也可以在调用 include() 的 CMakeLists.txt 文件中直接访问，同样的对于 macro() 也适用，在根目录 CMake 文件中调用宏，即取消 test(${MY_VAL}) 以及 message(“macro_val=${macro_val}”) 部分的注释，此时最后输出结果 ： 12345678$ cmake .父目录 CMakeLists.txt 文件第一次在父目录 MY_VAL=666进入 Findtest.cmake 文件macro is MY_VAL=000第二次在父目录，MY_VAL=999include test=222macro_val=1 可以看出，这次输出的结果在第二次进入父目录后，MY_VAL 变量的值就是 999 了。注意到在根目录中 CMakeLists.txt 中 注释语句中有一个 find_package() ，这个和 include() 其实都是一样的结果。 总结: 结合 include() 、macro() 最后结果，能够得出一个结论：通过 include() 和 macro() 相当于把这两部分包含的代码直接加入根目录 CMakeLists.txt 文件中去执行，相当于他们是一个整体。因此变量直接都是互通的。这就有点像 C/C++ 中的 #include 包含头文件的预处理过程了。这一点其实与刚开始讲的 function() 、add_subdirectory() 完全不同，在函数以及 add_subdirectory() 中，他们本身就是一个不同的作用域范围，仅仅通过拷贝调用者的 Normal 值(仅仅在调用 add_subdirectory() / function() 之前的 Normal 变量)，如果要修改调用者包含的 Normal 变量，那么只能通过 set(MY_VAL &quot;某个值&quot; PARENT_SCOPE)注明我们修改的是调用者 Normal 值。虽然在 C/C++ 中，可以通过指针的方式，通过函数可以修改外部变量值，但是在 CMake 脚本语言中 function() 虽然能够传入形式参数，但是者本质上就是 C/C++ 中的值拷贝。而不是引用。上面所说的 Normal 变量其实就是一个局部变量。 2、Cache Variables相当于一个全局变量，我们在同一个 cmake 工程中都可以使用。Cache 变量有以下几点说明: Cache 变量 CMAKE_INSTALL_PREFIX 默认值是 /usr/local (可以在生成的 CMakeCache.txt 文件中查看)，这时候如果我们 在某个 CMakeLists.txt 中，仍然使用 set(CMAKE_INSTALL_PREFIX “/usr”)，那么此时我们 install 的时候，CMake 以后面的 /usr 作为 CMAKE_INSTALL_PREFIX 的值，这是因为 CMake 规定，有一个与 Cache 变量同名的 Normal 变量出现时，后面使用这个变量的值都是以 Normal 为准，如果没有同名的 Normal 变量，CMake 才会自动使用 Cache 变量。 所有的 Cache 变量都会出现在 CMakeCache.txt 文件中。这个文件是我们键入 cmake .命令后自动出现的文件。打开这个文件发现，CMake 本身会有一些默认的全局 Cache 变量。例如：CMAKE_INSTALL_PREFIX、CMAKE_BUILD_TYPE、CMAKE_CXX_FLAGSS 等等。可以自行查看。当然，我们自己定义的 Cache 变量也会出现在这个文件中。Cache 变量定义格式为 set(&lt;variable&gt; &lt;value&gt; CACHE STRING INTERNAL)。这里的 STRING可以替换为 BOOL FILEPATH PATH ，但是要根据前面 value 类型来确定。参考。 修改 Cache 变量。可以通过 set(&lt;variable&gt; &lt;value&gt; CACHE INSTERNAL FORCE)，另一种方式是直接在终端中使用 cmake -D var=value ..来设定默认存在的CMake Cache 变量。 下面通过一个例子来说明以上三点: 首先看一下目录树结构: 1234567$ tree.├── CMakeLists.txt└── src └── CMakeLists.txt1 directory, 2 files 根目录 CMakeLists.txt 文件内容如下: 123456789cmake_minimum_required(VERSION 3.10)set(MY_GLOBAL_VAR "666" CACHE STRING INTERNAL )message("第一次在父目录 CMAKE_INSTALL_PREFIX=$&#123;CMAKE_INSTALL_PREFIX&#125;")message("第一次在父目录 MY_GLOBAL_VAR=$&#123;MY_GLOBAL_VAR&#125;")add_subdirectory(src)message("第二次在父目录 CMAKE_INSTALL_PREFIX=$&#123;CMAKE_INSTALL_PREFIX&#125;")message("第二次在父目录 MY_GLOBAL_VAR=$&#123;MY_GLOBAL_VAR&#125;")set(CMAKE_INSTALL_PREFIX "--&gt;usr" )message("第三次在父目录 CMAKE_INSTALL_PREFIX=$&#123;CMAKE_INSTALL_PREFIX&#125;") src/CMakeLists.txt 文件内容如下: 12345cmake_minimum_required(VERSION 3.10)message("子目录,CMAKE_INSTALL_PREFIX=$&#123;CMAKE_INSTALL_PREFIX&#125;")message("子目录,MY_GLOBAL_VAR=$&#123;MY_GLOBAL_VAR&#125;")set(CMAKE_INSTALL_PREFIX "/usr" CACHE STRING INTERNAL FORCE)set(MY_GLOBAL_VAR "777" CACHE STRING INTERNAL FORCE ) 运行结果: 12345678$ cmake .第一次在父目录 CMAKE_INSTALL_PREFIX=/usr/local第一次在父目录 MY_GLOBAL_VAR=666子目录,CMAKE_INSTALL_PREFIX=/usr/local子目录,MY_GLOBAL_VAR=666第二次在父目录 CMAKE_INSTALL_PREFIX=/usr第二次在父目录 MY_GLOBAL_VAR=777第三次在父目录 CMAKE_INSTALL_PREFIX=--&gt;usr 程序说明：首先在根目录中打印一下当前的 Cache 变量 CMAKE_INSTALL_PREFIX 值，主要看看默认值是什么，然后在子目录 src/CMakeLists.txt 中再次打印和修改该 Cache 值，目的是熟悉修改全局 Cache 变量，当返回根目录 CMakeLists.txt 文件中再次执行第二次打印该 Cache 值时，主要看一看在子目录中修改后的效果。接着在根目录中设定一个 CMAKE_INSTALL_PREFIX 的 Normal 同名变量，此时第三次打印 CMAKE_INSTALL_PREFIX 的值，此时是为了证明，当有与 Cache 同名的 Normal 变量出现时，CMake 会优先使用 Normal 属性的值。通过设定 MY_GLOBAL_VAR 主要是为了说明可以自己设定全局 Cache 变量。最后的结果如上面显示，当我们再次执行 cmake . 的时候，程序结果如下: 12345678$ cmake .第一次在父目录 CMAKE_INSTALL_PREFIX=/usr第一次在父目录 MY_GLOBAL_VAR=777子目录,CMAKE_INSTALL_PREFIX=/usr子目录,MY_GLOBAL_VAR=777第二次在父目录 CMAKE_INSTALL_PREFIX=/usr第二次在父目录 MY_GLOBAL_VAR=777第三次在父目录 CMAKE_INSTALL_PREFIX=--&gt;usr 可以发现第一次在父目录打印 CMAKE_INSTALL_PREFIX 和 MY_GOLBAL_VAR 时，他们的结果是上次cmake .后生成的值，存储在 CMakeCache.txt 中，自己可以找到，解决方案就是可以把 CMakeCache.txt 文件删除，然后在 cmake .我们以后在实际使用时要注意这个坑。对于修改 Cache 变量的另一种方式就是cmake -D CMAKE_INSTALL_PREFIX=/usr。可以自己验证。这里说一个重要的点，就是在终端中输入的 cmake -D var=value . 如果 CMake 中默认有这个 var Cache 变量，那么此时就是赋值，没有的话，CMake 就会默认创建了一个全局 Cache 变量然后赋值。(tips: $CACHE{VAR}表示获取 CACHE 缓存变量的值)。例子如下:(目录结构同上) 根目录 CMakeLists.txt : 123456cmake_minimum_required(VERSION 3.10)set(MY_GLOBAL_VAR "666")message("第一次在父目录 MY_GLOBAL_VAR=$CACHE&#123;MY_GLOBAL_VAR&#125;")add_subdirectory(src)message("第二次在父目录局部 MY_GLOBAL_VAR=$&#123;MY_GLOBAL_VAR&#125;")message("第二次在父目录全局 MY_GLOBAL_VAR=$CACHE&#123;MY_GLOBAL_VAR&#125;") src/CMakeLists.txt : 123cmake_minimum_required(VERSION 3.10)message("子目录,MY_GLOBAL_VAR=$&#123;MY_GLOBAL_VAR&#125;")set(MY_GLOBAL_VAR "777" CACHE STRING INTERNAL FORCE ) 运行结果： 1234第一次在父目录 MY_GLOBAL_VAR=8子目录,MY_GLOBAL_VAR=666第二次在父目录局部 MY_GLOBAL_VAR=666第二次在父目录全局 MY_GLOBAL_VAR=777 有了上面的基础，相信这个例子很快能看明白。 参考:1、https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables/31044116#31044116 2、https://stackoverflow.com/questions/3249459/for-the-cmake-include-command-what-is-the-difference-between-a-file-and-a-mod 3、https://cmake.org/cmake/help/v3.11/command/set.html#set]]></content>
      <categories>
        <category>linux</category>
        <category>tool</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
</search>
